---
title: Consistency without a central authority
subtitle: All about CRDTs

description: |
  Something something something

draft: true

date: '2022-01-20'
thumbnail: /images/posts/thumbnails/roads.jpg
image: /images/posts/roads/roads.jpg
tags: software

caption: |
  Sed lectus. Praesent elementum hendrerit tortor. Sed semper lorem at felis.
---

There are a number of reasons why we don't live in a local-first world yet, which can mostly can be
summarized as "there are a bunch of things we’re still figuring out how to do without a server."

One of the things that makes a server a server is that it's **authoritative**. By that we mean that
_we've agreed that it is our single source of truth_. An application built around a single central
server gets **consistency** for free, meaning that we can edit shared data without having to worry
about conflicts.

This is maybe the first problem that comes to mind for most people when thinking about peer-to-peer
collaboration, and it’s the one that has generated the most attention and research: **How do you
resolve conflicts** when two peers try to sync up? Without an authoritative server, we don't get
consistency for free. If two peers are equally authoritative and they _diverge_ — there are
differences between the data on their respective devices — then how do we resolve those
discrepancies and get them back in a consistent state?

After spending much of the last couple of years thinking about this and working on this, I feel like
I have a pretty solid handle on how this problem is solved, and I'd like to explain it as simply as
possible — because, despite appearances, the solution is fairly straightforward.

The solution involves something with the fearsome name of **conflict-free replicated data types**
(CRDTs). These were first defined in 2011 and have been the subject of a lot of research since then.
The academic papers on the subject might be interesting and they serve to put the field on a solid
theoretical footing; but you don't need to understand what a semilattice is, or be able to follow
the formal correctness proofs, in order to understand how this all works.

But do keep in mind that decentralized systems work very differently from centralized systems, and
so there are some very basic things that we take for granted that we have to think about in a very
different way.

###

Let's start out by talking about how traditional cloud-based applications work and why we don't have
to worry about consistency in that world.

Let's suppose Alice and Bob are using a cloud-based project management tool -- think of something
like Basecamp, or Asana, or Monday. They both have the same permissions. Alice assigns a task to
Bob; at about the same time, Bob assigns the same task to Alice. Which assignment is kept?

Clearly, it depends on which change is most _recent_ -- in other words, the last change "wins". If
Alice makes her change at 10:01 and Bob makes his change at 10:02, then if I go to look at the task
at 10:03, I'm going to see Bob's edit.

Even if they make their changes at precisely the same time and both hit `Enter` simultaneously, one
change will randomly get to the server first, and the later change will be the one that's kept. Of
course, Alice and Bob could get into an "edit war", assigning the task back and forth like two
Wikipedia editors who disagree on who killed JFK. But once the dust settles, whatever assignment was
entered _last_ is the one that you and I will see the next day; there's no possibility that you and
I will see different assignments. Our views of the data are guaranteed to be _consistent_, simply
because there's only one authoritative version of the data, and it can only have one value for that
field.

### What is "time", anyway?

But in a local-first world, we only have _peers_: The very term implies equality. One peer is
presumed to be just as authoritative as another.

Now, if Bob and Alice are connected, then last-write-wins still applies. The difficulty comes when
Alice and Bob make their changes while disconnected: Say Alice is working offline while on a plane,
and she assigns the task to Bob. While she's still in the air, Bob assigns the task to Alice. When
Alice lands and reconnects to Bob, which assignment is kept?
